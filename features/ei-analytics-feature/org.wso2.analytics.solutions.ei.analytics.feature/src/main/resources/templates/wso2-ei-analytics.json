{
   "templateGroup": {
      "uuid": "wso2-ei-analytics",
      "name": "WSO2 EI Analytics",
      "description": "Real Time Analytics of EI",
      "ruleTemplates": [
         {
            "uuid": "ei_analytics_statapp",
            "name": "EI Messages Table",
            "description": "Enables or disables EI Messages Table",
            "type": "template",
            "instanceCount": "one",
            "script": "var enableMessages = '${userInputForEnableMessages}';\n\n\n\n\n\n\n\n\n\n",
            "templates": [
               {
                  "type": "siddhiApp",
                  "content": "@App:name('EI_Analytics_StatApp')\n@App:description('SiddhiApp for EI Analytics')\n\n-- Streams\n\n-- temporary stream to store ESBStat data\ndefine stream PreProcessedESBStatStream (componentId string, componentName string, componentType string, duration long, faultCount int, startTime long, entryPoint string, metaTenantId int);\n\n-- temporary stream to store MediatorStat data\ndefine stream PreProcessedMediatorStatStream (metaTenantId int, entryPoint string, entryPointHashcode string, componentId string, hashCode string, componentName string, componentType string, duration long, faultCount int, startTime long);\n\n-- maps Flow Entry into FlowEntryEventStream\n@source(type = 'wso2event', wso2.stream.id = 'org.wso2.esb.analytics.stream.FlowEntry:1.0.0',\n\t@map(type = 'wso2event'))\ndefine stream FlowEntryEventStream (meta_compressed bool, meta_tenantId int, messageId string, flowData string);\n\n-- maps Config entry into ConfigEntryEventStream\n@source(type = 'wso2event', wso2.stream.id = 'org.wso2.esb.analytics.stream.ConfigEntry:1.0.0',\n\t@map(type = 'wso2event'))\ndefine stream ConfigEntryEventStream (meta_tenantId int, hashcode string, entryName string, configData string);\n\n-- defines the DecompressedEventStream, which stores decompressed FlowEntryEventStream data\ndefine stream DecompressedEventStream (metaTenantId int, messageFlowId string, host string, hashCode string, componentName string, componentType string, componentIndex int, componentId string, startTime long, endTime long, duration long, beforePayload string, afterPayload string, contextPropertyMap string, transportPropertyMap string, children string, entryPoint string, entryPointHashcode string, faultCount int, eventTimestamp long);\n\n-- defines the TableInsertAsyncStream, which inserts events asynchronously into ESBEventTable\n@Async(buffer.size = '8192', workers = '4', batch.size.max = '2000')\ndefine stream ESBEventTableInsertAsyncStream (metaTenantId int, messageFlowId string, host string, hashCode string,\ncomponentName string, componentType string, componentIndex int, componentId string, startTime long, endTime long, duration long, beforePayload string, afterPayload string, contextPropertyMap string, transportPropertyMap string, children string, entryPoint string, entryPointHashcode string, faultCount int, eventTimestamp long);\n\n-- Tables\n\n-- table that stores ESBEventStream data\n@store(type = 'rdbms', datasource = 'EI_ANALYTICS', field.length=\"contextPropertyMap:5000,beforePayload:5000,afterPayload:5000,transportPropertyMap:5000\" )\n@Index('metaTenantId','messageFlowId')\ndefine table ESBEventTable (metaTenantId int, messageFlowId string, host string, hashCode string, componentName string, componentType string, componentIndex int, componentId string, startTime long, endTime long, duration long, beforePayload string, afterPayload string, contextPropertyMap string, transportPropertyMap string, children string, entryPoint string, entryPointHashcode string, faultCount int, eventTimestamp long);\n\n-- table that stores ConfigEntryEventStream data\n@store(type = 'rdbms', datasource = 'EI_ANALYTICS', field.length=\"configData:6000\")\n@PrimaryKey('hashcode')\n@Index('metaTenantId','entryName')\ndefine table ConfigEntryTable (metaTenantId int, hashcode string, entryName string, configData string, eventTimestamp long);\n\n-- table that stores component name and type for the searchbox-widget\n@PrimaryKey('componentId')\n@Index('componentType')\ndefine table ComponentNameInMemoryTable (componentId string, componentName string, componentType string);\n\n@store(type = 'rdbms', datasource = 'EI_ANALYTICS')\n@PrimaryKey('componentId')\n@Index('componentType')\ndefine table ComponentNameTable (componentId string, componentName string, componentType string);\n\n-- Aggregations\n\n-- aggregates PreProcessedMediatorStatStream data every minute to month\n@store(type = 'rdbms', datasource = 'EI_ANALYTICS')\n@info(name = 'MediatorStat')\n@purge(enable='true', interval='60 min', @retentionPeriod(sec='1 day', min='72 hours', hours='90 days', days='1 year', months='2 years', years='3 years'))\n@PartitionById\ndefine aggregation MediatorStatAgg\nfrom PreProcessedMediatorStatStream\n select metaTenantId, entryPoint, entryPointHashcode, componentId, hashCode, componentName, componentType, sum(duration) as totalDuration ,avg(duration) as avgDuration, min(duration) as minDuration, max(duration) as maxDuration, count() as noOfInvocation, sum(faultCount) as faultCount, startTime\n\tgroup by metaTenantId, componentId, componentName, componentType, entryPoint, entryPointHashcode, hashCode\n\taggregate by startTime every sec...years;\n\n-- aggregates PreProcessedESBStatStream data every minute to month\n@store(type = 'rdbms', datasource = 'EI_ANALYTICS')\n@purge(enable='true', interval='60 min', @retentionPeriod(sec='1 day', min='72 hours', hours='90 days', days='1 year', months='2 years', years='3 years'))\n@info(name = 'ESBStat')\n@PartitionById\ndefine aggregation ESBStatAgg\nfrom PreProcessedESBStatStream\n select componentId, componentName, componentType, sum(duration) as totalDuration, avg(duration) as avgDuration, min(duration) as minDuration, max(duration) as maxDuration, count() as noOfInvocation, sum(faultCount) as faultCount, entryPoint, metaTenantId, startTime as eventTimestamp\n\tgroup by metaTenantId, componentId, componentName, componentType, entryPoint\n\taggregate by startTime every sec...years;\n\n--Triggers\ndefine trigger TablePurgingTriggerStream at '0 0 23 * * ?';\ndefine trigger AppStartTriggerStream at 'start';\n\n-- Queries\n\n-- decompress compressed-FlowEntryEventStream and store data in DecompressedEventStream\nfrom FlowEntryEventStream#esbAnalytics:decompress(meta_compressed, meta_tenantId, messageId, flowData)\nselect metaTenantId, messageFlowId, host, hashCode, componentName, str:lower(componentType) as componentType, componentIndex, componentId, startTime, endTime, duration, beforePayload, afterPayload, contextPropertyMap, transportPropertyMap, children, entryPoint, entryPointHashcode, faultCount, _timestamp as eventTimestamp\ninsert current events into DecompressedEventStream;\n\n-- store ConfigEntryEventStream data into ConfigEntryTable\nfrom ConfigEntryEventStream\nselect meta_tenantId as metaTenantId, hashcode, entryName, configData, eventTimestamp() as eventTimestamp\nupdate or insert into ConfigEntryTable on ConfigEntryTable.hashcode == hashcode;\n\n-- add all the componentIds, componentNames and componentTypes to ComponentNameTable\nfrom AppStartTriggerStream join ComponentNameTable\nselect componentId, componentName, componentType\ninsert into ComponentNameInMemoryTable;\n\nfrom DecompressedEventStream[not((ComponentNameInMemoryTable.componentId == componentId) in ComponentNameInMemoryTable)]\nselect componentId, componentName, componentType\ninsert into ComponentNameTableStream;\n\nfrom ComponentNameTableStream\nselect *\ninsert into ComponentNameInMemoryTable;\n\nfrom ComponentNameTableStream\nselect *\ninsert into ComponentNameTable;\n\n-- if DecompressedEventStream has beforePayload or transportPropertyMap or contextPropertyMap, add them to into ESBEventTable through an async stream\nfrom DecompressedEventStream[(not(beforePayload is null) or not(transportPropertyMap is null) or not(contextPropertyMap is null)) and ${enableMessages}]\nselect metaTenantId, messageFlowId, host, hashCode, componentName, componentType, componentIndex, componentId, startTime, endTime, duration, beforePayload, afterPayload, contextPropertyMap, transportPropertyMap, children, entryPoint, entryPointHashcode, faultCount, eventTimestamp\ninsert current events into ESBEventTableInsertAsyncStream;\n\nfrom ESBEventTableInsertAsyncStream\nselect *\ninsert current events into ESBEventTable;\n\n-- if DecompressedEventStream's componentType is ProxyService or API or InboundEndPoint, add it into PreProcessedESBStatStream\nfrom DecompressedEventStream[componentType == \"proxy service\" or componentType == \"api\" or componentType == \"inbound endpoint\"]\nselect componentId, componentName, componentType, duration, ifThenElse(faultCount > 0, 1, 0) as faultCount, startTime, entryPoint, metaTenantId\ninsert current events into PreProcessedESBStatStream;\n\n-- insert DecompressedEventStream data into PreProcessedMediatorStatStream\nfrom DecompressedEventStream\nselect metaTenantId, entryPoint, entryPointHashcode, componentId, hashCode, componentName, componentType, duration, ifThenElse(faultCount > 0, 1, 0) as faultCount, startTime\ninsert current events into PreProcessedMediatorStatStream;\n\nfrom    TablePurgingTriggerStream\nselect  time:dateSub(triggered_time, 2, 'week') as purgingTime\ndelete  ConfigEntryTable\non      ConfigEntryTable.eventTimestamp < purgingTime;\n\nfrom    TablePurgingTriggerStream\nselect  time:dateSub(triggered_time, 2, 'week') as purgingTime\ndelete  ESBEventTable\non      ESBEventTable.eventTimestamp < purgingTime;"
               }
            ],
            "properties": {
               "userInputForEnableMessages": {
                  "fieldName": "Enable EI message storing",
                  "description": "Enabling EI Messages will cause all the message details to be stored. Hence, a performance drop can happen.",
                  "defaultValue": "true",
                  "options": [
                     "true",
                     "false"
                  ]
               }
            }
         }
      ]
   }
}